/* Generated by Nim Compiler v0.10.2 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: MacOSX, amd64, clang */
/* Command for C compiler:
   clang -c  -w  -I/Users/erikoleary/lib/Nim/lib -o /Users/erikoleary/Documents/onion-nimrod/sampleweb/nimcache/stdlib_pcre.o /Users/erikoleary/Documents/onion-nimrod/sampleweb/nimcache/stdlib_pcre.c */
#define NIM_INTBITS 64
#include "nimbase.h"
typedef struct tpcre187621 tpcre187621;
typedef struct TGenericSeq TGenericSeq;
typedef struct NimStringDesc NimStringDesc;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct textra187632 textra187632;
typedef N_CDECL_PTR(void, TY187911) (tpcre187621* p);
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
typedef N_CDECL_PTR(tpcre187621*, TY187673) (NCSTRING a2, int a3, NCSTRING* a4, NI32* a5, NIM_CHAR* a6);
typedef N_CDECL_PTR(void, TY187771) (NCSTRING a2);
struct  tpcre187621  {
char dummy;
};
typedef N_NIMCALL_PTR(void, TY3089) (void* p, NI op);
typedef N_NIMCALL_PTR(void*, TY3094) (void* p);
struct  TNimType  {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY3089 marker;
TY3094 deepcopy;
};
struct  textra187632  {
NI Flags;
void* Studydata;
NI Matchlimit;
void* Calloutdata;
NCSTRING Tables;
NI Matchlimitrecursion;
NCSTRING* Mark;
void* Executablejit;
};
struct  TNimNode  {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
typedef N_CDECL_PTR(textra187632*, TY187861) (tpcre187621* a2, int a3, NCSTRING* a4);
typedef N_CDECL_PTR(int, TY187755) (tpcre187621* a2, textra187632* a3, NCSTRING a4, int a5, int a6, int a7, NI32* a8, int a9);
N_NIMCALL(void*, nimLoadLibrary)(NimStringDesc* path);
N_NOINLINE(void, nimLoadLibraryError)(NimStringDesc* path);
N_NIMCALL(void*, nimGetProcAddr)(void* lib, NCSTRING name);
static N_INLINE(void, nimFrame)(TFrame* s);
N_NOINLINE(void, stackoverflow_19001)(void);
static N_INLINE(void, popFrame)(void);
STRING_LITERAL(TMP690, "libpcre.3.dylib", 15);
STRING_LITERAL(TMP691, "libpcre.1.dylib", 15);
STRING_LITERAL(TMP692, "libpcre.dylib", 13);
STRING_LITERAL(TMP693, "libpcre(.3|.1|).dylib", 21);
TY187911 pcrefree_187915;
static void* TMP689;
TY187673 Dl_187672;
TY187771 Dl_187770;
TNimType NTI187621; /* TPcre */
TNimType NTI187912; /* ptr TPcre */
TNimType NTI187632; /* TExtra */
extern TNimType NTI108; /* int */
extern TNimType NTI153; /* pointer */
extern TNimType NTI151; /* cstring */
extern TNimType NTI76257; /* ptr cstring */
TNimType NTI189022; /* ptr TExtra */
TY187861 Dl_187860;
TY187755 Dl_187754;
extern TFrame* frameptr_16442;

static N_INLINE(void, nimFrame)(TFrame* s) {
	NI LOC1;
	LOC1 = 0;
	{
		if (!(frameptr_16442 == NIM_NIL)) goto LA4;
		LOC1 = 0;
	}
	goto LA2;
	LA4: ;
	{
		LOC1 = ((NI) ((NI16)((*frameptr_16442).calldepth + ((NI16) 1))));
	}
	LA2: ;
	(*s).calldepth = ((NI16) (LOC1));
	(*s).prev = frameptr_16442;
	frameptr_16442 = s;
	{
		if (!((*s).calldepth == ((NI16) 2000))) goto LA9;
		stackoverflow_19001();
	}
	LA9: ;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_16442 = (*frameptr_16442).prev;
}
NIM_EXTERNC N_NOINLINE(void, stdlib_pcreInit)(void) {
	nimfr("pcre", "pcre.nim")
	popFrame();
}

NIM_EXTERNC N_NOINLINE(void, stdlib_pcreDatInit)(void) {
static TNimNode* TMP697[8];
static TNimNode TMP684[10];
NTI187621.size = sizeof(tpcre187621);
NTI187621.kind = 18;
NTI187621.base = 0;
NTI187621.flags = 3;
TMP684[0].len = 0; TMP684[0].kind = 2;
NTI187621.node = &TMP684[0];
NTI187912.size = sizeof(tpcre187621*);
NTI187912.kind = 21;
NTI187912.base = (&NTI187621);
NTI187912.flags = 3;
NTI187632.size = sizeof(textra187632);
NTI187632.kind = 18;
NTI187632.base = 0;
NTI187632.flags = 3;
TMP697[0] = &TMP684[2];
TMP684[2].kind = 1;
TMP684[2].offset = offsetof(textra187632, Flags);
TMP684[2].typ = (&NTI108);
TMP684[2].name = "flags";
TMP697[1] = &TMP684[3];
TMP684[3].kind = 1;
TMP684[3].offset = offsetof(textra187632, Studydata);
TMP684[3].typ = (&NTI153);
TMP684[3].name = "study_data";
TMP697[2] = &TMP684[4];
TMP684[4].kind = 1;
TMP684[4].offset = offsetof(textra187632, Matchlimit);
TMP684[4].typ = (&NTI108);
TMP684[4].name = "match_limit";
TMP697[3] = &TMP684[5];
TMP684[5].kind = 1;
TMP684[5].offset = offsetof(textra187632, Calloutdata);
TMP684[5].typ = (&NTI153);
TMP684[5].name = "callout_data";
TMP697[4] = &TMP684[6];
TMP684[6].kind = 1;
TMP684[6].offset = offsetof(textra187632, Tables);
TMP684[6].typ = (&NTI151);
TMP684[6].name = "tables";
TMP697[5] = &TMP684[7];
TMP684[7].kind = 1;
TMP684[7].offset = offsetof(textra187632, Matchlimitrecursion);
TMP684[7].typ = (&NTI108);
TMP684[7].name = "match_limit_recursion";
TMP697[6] = &TMP684[8];
TMP684[8].kind = 1;
TMP684[8].offset = offsetof(textra187632, Mark);
TMP684[8].typ = (&NTI76257);
TMP684[8].name = "mark";
TMP697[7] = &TMP684[9];
TMP684[9].kind = 1;
TMP684[9].offset = offsetof(textra187632, Executablejit);
TMP684[9].typ = (&NTI153);
TMP684[9].name = "executable_jit";
TMP684[1].len = 8; TMP684[1].kind = 2; TMP684[1].sons = &TMP697[0];
NTI187632.node = &TMP684[1];
NTI189022.size = sizeof(textra187632*);
NTI189022.kind = 21;
NTI189022.base = (&NTI187632);
NTI189022.flags = 3;
if (!((TMP689 = nimLoadLibrary((NimStringDesc*) &TMP690))
||(TMP689 = nimLoadLibrary((NimStringDesc*) &TMP691))
||(TMP689 = nimLoadLibrary((NimStringDesc*) &TMP692))
)) nimLoadLibraryError((NimStringDesc*) &TMP693);
	Dl_187672 = (TY187673) nimGetProcAddr(TMP689, "pcre_compile");
	Dl_187770 = (TY187771) nimGetProcAddr(TMP689, "pcre_free_substring");
	Dl_187860 = (TY187861) nimGetProcAddr(TMP689, "pcre_study");
	Dl_187754 = (TY187755) nimGetProcAddr(TMP689, "pcre_exec");
}

